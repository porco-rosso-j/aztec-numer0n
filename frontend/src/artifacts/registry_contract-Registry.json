{"noir_version":"0.23.0+5f5843e35052b9d3599b8ab4f7633db0a225e82f","name":"Registry","functions":[{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"preimage","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"preimage":[],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[4,5,6,7]},"bytecode":"H4sIAAAAAAAA/+2WwW7DIAyGTSAkhFTabTvmEVIthx33/g81DW9284e2p5pDpVpCgAn2Z8chDETk6F98aT1di65/S78+JmdDW2tLTvcknN2TcHpDTneDk/sgY+65lmNpQ2mfoh9h32LFs61fkXbngY6SS+uIDous88oNOt3bgU6/SR/2GKJ9DNsouTK1W9472/yA/IdG7L09e6uc/NWv1mIU2+qnh1wlGRueRWf07aQl8EnyjnT8TrskGGtNK/dMe12mO3tCtecE6/FG3Itx3AOwLDBXf73EwfLGvNU3zWyTPduW6Xg2sbhqvsB4apyrRnGubDeLrR+y/W/NkJ+xytMJ1jM8MzfInQO/alvnyPjiffEiw1SxZlhPoOuqWPAugc/X54dpQOoQLztO4Dzo7l3ILvILnT1C/YIMAAA=","debug_symbols":"q1bKyU9OLMnMzytWsqqu1VEqSyzKTEzKSYVySyoLIMxaAA=="},{"name":"add_game","function_type":"Open","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"public_global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},"visibility":"private"},{"name":"game_address","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"game_address":[{"start":34,"end":35}],"inputs":[{"start":0,"end":34}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"contract_storage_update_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest","fields":[{"name":"storage_slot","type":{"kind":"field"}},{"name":"new_value","type":{"kind":"field"}}]}}},{"name":"contract_storage_reads","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::contrakt::storage_read::StorageRead","fields":[{"name":"storage_slot","type":{"kind":"field"}},{"name":"current_value","type":{"kind":"field"}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"prover_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"public"},"return_witnesses":[35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221]},"bytecode":"H4sIAAAAAAAA/+3dB3gU17UH8Fl1sVoJJCSBCixFEh0VDO7GvQAuuHdjg0uCwQHce+81rol7791O4l7imrj39uK8F8d56T12Ejvv3Nl7rD+jWaGbzMVneWe+73h3zuzM/d0zd2ZXO7P4oyAIUkFuKqYYHfSdePlM+9j5n01dCW6r06czVSDOogJxFheIs6RAnKUF4iwrEGd5gTgrCsRZmaDT2IqC5aekvYM81DVpYzoojH1fVSDOTIE4qwvEWVMgzsEF4hxSIM7aAnHWFYhzaIE46wvE2VAgzsYCcQ4rEOfwAnE2FYizuUCcLQXibC0Q54gCcY4sEGe2QJyjCsQ5OkFnOzjH2Mex9rHNPvJrOuzjOPs43j5OsI8TbV9L7PwkiskUUyim2mVZdlOYL8e7KXooplGsRjGdYgbF6hRrUKxJsRbF2hTrUKxLsZ7t//oUG1BsSLERxcYUm1BsSrEZxeYUW1DMophNMYdiS4qtIpatKbahmEuxLcV2FNtT7ECxI8VOFDtT7EKxK8VuFLtT7EGxJ8VeFPMo9qbYh2I+xQKKfSn2o9if4gCKb1B8k2IhxYEUiygWR2p2EMW3KJZQLI04l1EcTHEIxaEUh1EcTnEExZEUR1EcTXEMxbEUx1EcT3ECxYkUJ1GcTHEKxakUp1GcTnEGxZkUZ1GcTXEOxbkU51GcT3EBxbethQf2hRQXUVxMcQnFpRSXUXyH4rsUl1NcQXElxVUUV1NcQ3EtxXUU11PcQHEjxU0UN1PcQnErxW0Ut1PcQXEnxV0Ud1PcQ3EvxX0U91M8QPEgxfcovk/xA4qHKB6meITiUYrHKB6neILiSYqnKJ62feHv2H5I8Uwk9yzFc/b58/bxBfv4YuS1P6L4sX3+kn182T6+Yh9ftY+v2cfX7eMb9vFN+/iWfXzbPr5jH9+1j+/Zx/ft4wf28UP7+BHF3Lrc84qgd8oGCZ0zps1fYL7j5gE7Jlh+MjUptsv4MWvzJXaeH7mGpXa+NJIvs/NlkXy5nS+PbL/SzldG8hk7n4nka+x8TSQ/xM4PieTr7HxdJF9v5+shnw7gO1ybN7lim0pBjo/9IsiV2lwx5Mp4c5Art7lSyPF+L4Ncpc2VQ26QzVVALm1zXEOzraqgt18z7fPO/2Sa1jnPbDeT9Hbtd8bVdltV0K8am8tAbrDNVUNuiM3VQK7W5gZDzh5iX40Rkxtqc7WQq7e5Osg12NxQyDXaXD3khtlcA+SG21wj5Jpsbhjkmm1uOORabK4Jcq021wy5ETbXArmRNtcKuazNjYDcKJsbCbnRNpeFHJ83RkFurM2N5uM76D2fhuvYfBHkxvK5BnJtfJ6BXDufYyDXwecXyI2Dtjk3Ho4Fzk3gcw3kJtrcV8dVkPuME/Y9SOrY6d7HbLc76e3Sls12pyW/3fB61mpBb62z0E431Gq6fZ7gvQhd2HbKBrfD+RJ4vlnQO02H53xeZLc5J/bEvA6fd0XWycDynph+ZxPu9zSwZGGe2zPHwjrgSH6s9nT6GavdnTpWc3+fBJF9aiZ+X13VxuoscCQ/VlfTsTrwyXmszg96Jxx3/LlsVRurO4Mj+bE6o1M/Awx4ch6rS4LeCccd/22wqo3V/cDhYaxO0/PqgCfnsXpc0DvhuOO/T1e1sXowOJIfq2t4Gqs9OlaD3PfKQWSfmom/I1nVxuqJ4Eh+rO7jaax2dutYzV2/CCL71Ez8Pd2qNlbPB4eHsTpdx+qAJ+exemvQO+G44++KV7WxepV9br6Te95+59oMuRdsrgVyL9pcK/TBwzjfW8f5gCfncf5w0DvhmOXrFavaOL/bPjfj9yW4tsi5l21uFOResbnRkHs1cq3W5F6zubGQe93m2iD3hs21Q+5Nm+uA3Fs2Nw5yb9vceMi9Y3MTIPeuzU2E3Hs2Nwly79vcZMh9YHNTIPehzU2F3Ec2x/cvmGt/fD2Jx1UFWLNBstckuS48pSLzWXg+HjwTkvf0pKGNgXgmxHi+TLA+GagPtjUp+b6H+2JiMPC+TwLPZA8es90pyW83HOZToR/cZ24rA8vHQh+neuhjCtrlbfP8VPCMj1jT8LrxQoycw/PS1BhjZ/LG7lSw/D7NwnwnGDk3GTwexlh3OuIxU3/H0hTwJP7Zi74PxPEyEE8XeDzsry4//exc7rv/BM/DYQl6gr77i/uQgeX42bDHQ+1S0C5vm+fRqF71qle96lWvetWrXvWqV73qVa961ate9apXvepdsRevHeD1VH7dVCFGznWCx8f37OFvCe22ePvmuvxhqd52k78m2N2J16L4ngx2cHsl8JpUba/tKGurCvpevzL9mRTJmT5MTLwPuX3JbfG2eZ7bq4L+4HVWH9d9U9AWb3vVbzv3W9Hk7yHo7qwOcr995TE2IdIfvIbbHsmZcXoGHEPjEvflas6/g+Nt8/y4QNuWdJ8L3v9RBEYP9750/bv3vuD9CcVg9HHuTEO7AzFOBCOvVwJGSffRZILlzwNsTP59NGec5GCcDEZerwyMHu6hCI2THYx4/w6vVw5GH/fGuN5XEXe/TAU8+rjXwvVelLj7ZSrB6OHzZGjsDAZuxL8TeD38tyU83GfchZ/3B2LsBiOvl/Zs7O89zvPfUeE9T93BwOuDf7fwelVQp7i//zzc5x3WrCdi5Hm8Bxq9Pj3piGdFdYwzVoNxNU/GaQ7G1cDI69WA0ce95GlodyDG6WDk9QaDcYYn43QH4www8npDwLi6J+MMB+PqYOT1asG4hifj6g7GNcDI69WBcU1PxjUcjGuCkdcbCsa1PBnXdDCuBUZerx6Ma3syruVgXBuMvF4DGNfxZFzbwbgOGHm9RjCu68m4joNxXTDyesPAuJ4n47oOxvXAyOsNB+NMT8b1HIwzwcjrNYFxfU/GmQ7G9cHI6zWDcQNPxvUdjBuAkddrAeOGnowbOBg3BCOvh7+z3MiTcUMH40Zg5PVGgHFjT8aNHIwbg5HXGwnGTTwZN3YwbgLGjSPLjXFTT8ZNHIybgpHXGwXGzTwZN3UwbgZGXm80GDf3ZNzMwbg5GHm9MWDcwpNxcwfjFmDk9fB7nFmejFs4GGeBkddrB+Ps5I3h9xSzHIyzwTMneU9Ys9kOnjng2dKTZ46DZ0vwbJW8J9xfWzp4tgLPNol7cr+l28rBsw14tk7ck/stXfL9zP2Wbq7dVtK/pds26Lu/uA8ZWD4Xareth9qloF3eNs+jUb3qVa961ate9apXvepVr3rVq171qle96lWvetW7Yq/xbBmxpuF1Wwoxcm5rz550xGOmVGQ+C8/jjLhft/Nk3NbBuB0Y48be9p6M2zkYtwfjdjHGHZI3hteytncw7gCenRL35K5l7eDg2Qk8OybuyV3LSr6fuWtOOwd968ptZWA5joGdPfQxBe3ytnkejepVr3rVq171qle96lWvetWrXvWqV73qVa961aveFXuNZ/uINQ2v216IkXM7evakIx4zpSLzWXgeZ8T9uosn484Oxl3AGDf2dvVk3MXBuCsYd4kx7pa8MbzmtKuDcTfw7JG8Z1oa2hiIZw/w7J68p8tTP8NrTnsGfevKbWVgOY6BPT30MQXt8rZ5Ho3qVe+e4Nk1Yk3D63YVYuTc7p496YjHTP2dt+KMuF/38mTc08G4Fxjjxt685I3h+9FeDsZ54NkncU/uHoh5Dp59wLN34p7c+1Hy/cy9H80P+taV28rAchwD8z30MQXt8rZ5fr7ftsM6LFhBHRbEWBas5DqgcaDeuQXm1fpqfbW+Wt98Xq2v1lfrq/XN59X6an21vlrffF6tr9ZX66v1zefV+mp9tb7/mdd49opY0/C6vYQYObe3Z0864jFTKjKfhedxRhyH+3oyLnAw7gvGuGNlP0/GfR2M+4GR18PjY//kjeG1rP0cjPuD5xuJe3rCa1n7O3i+AZ4DEvfkrmUl38/cNZxvBn3rym1lYDmO02966GMK2uVt8zwaV1Xv/ALz6njw69XxoF4dD+rN59XxoF4dD+rN59XxoF4dD+rN59XxoF4dD+rN59XxoF4dD+rN59XxoF4dD+rN59XxoF4dD+rN55UwHoxnv4g1Da/bT4iRcwd49qQjHjOlIvNZeB5nxHG40JPxmw7GhWCMO1YO9GRc6GA8EIwLY4yLPBkPdDAuAiOvh8fw4uSN4X1hixyMi8HzLU+exQ6eb4HnoOQ9XZ76Gd4XtiToW1duKwPLcZwu8dDHFLTL2+Z5NBaS13gWRaxpeN0iIUbOHeTZk454zNTfcRVnxP261JNxiYNxKRjjxt6y5I3h+Wmpg3EZeA7x5Fnm4DkEPAcn7+ny1M/wfHlo0Leu3FYGluMYONRDH1PQLm+b59FYSF7jWRqxpuF1S4UYOXewZ0864jFTf8dVnBH362GejIc6GA8DY9zYO9yT8TAH4+FgPCzGeIQn4+EOxiPAyOsNAuORnoxHOBiPBCOvl/ZsTNn20JOJeEzbRyXfdvg+eGQw8PocBfXh9aqgTkfFuI/2VLOjIkaePxqM6PXpSUc8K6pjnLEajMd4Mh7tYDwGjLxeDRiP9WQ8xsF4LBh5vcFgPM6T8VgH43Fg5PWGgPF4T8bjHIzHg5HXqwXjCZ6MxzsYTwAjr1cHxhM9GU9wMJ4IRl5vKBhP8mQ80cF4Ehh5vXownuzJeJKD8WQw8noNYDzFk/FkB+MpYOT1GsF4qifjKQ7GU8HI6w0D42mejKc6GE8DI683HIynezKe5mA8HYy8XhMYz/BkPN3BeAYYeb1mMJ7pyXiGg/FMMPJ6LWA8y5PxTAfjWWDk9VrBeLYn41kOxrPByOvN9Wzs7++Us7VtbVvbXmltn+Oh7TS0wVN/5yA2ZGA9PAed68l4joPxXDCeE2M8z5PxXAfjeWA8N8Z4vifjeQ7G88HI6+E19gs8Gc93MF4Q40kl5+nMgAfbutBT378dDLzvbMjAemi8yJPxQgfjRWC8MMZ4sSfjRQ7Gi8HI6+E4v8ST8WIH4yVg5PXwfHGpJ+MlDsZLwcjrYR0vS94Yfpd9qYPxMvB815PnMgfPd8HzneQ9XZ76GV5jvjzoW1duKwPLcZxe7qGPKWiXt83zaCwkr/FcGrGm4XWXCjFy7juePemIx0z9HVdxRtyvV3gyXu5gvAKMvB6eL6/0ZLzCwXglGHk9rONVnoxXOhivAiOvh3W82pPxKgfj1WDk9bCO13gyXu1gvAaMvB7W8VpPxmscjNeCkdfDOl7nyXitg/E6MPJ6WMfrPRmvczBeD0ZeD+t4gyfj9Q7GG8DI62Edb/RkvMHBeCMYeT2s402ejDc6GG8C440xxps9GW9yMN4MxptijLd4Mt7sYLwFjDfHGG/1ZLzFwXgrGG+JMd7myXirg/E2MN4aY7zdk/E2B+PtYLwtxniHJ+PtDsY7wHh7jPFOT8Y7HIx3gvGOGONdnox3OhjvAuOdMca7PRnvcjDeDca7Yoz3eDLe7WC8B4x3xxjv9WS8x8F4LxjviTHe58l4r4PxPjDeG2O835PxPgfj/WDk9fCz2QOejPc7GB8A4/0xxgc9GR9wMD4IRl4P9/X3kjeG31E+6GD8Hnh+kLxnWhraGIjnB+D5fvKeLk/9DL8zfSjoW1duKwPLcQw85KGPKWiXt83zaFSveh8Cz4MRaxpe96AQI+e+79mTjnjM1N95K86I+/VhT8aHHIwPgzFu7D2SvDF8P3rYwfgIeB5L3DMt/P+tPOLgeQw8jybuyb0fJd/P3PvR40HfunJbGViOY+BxD31MQbu8bZ5H40C98wvMq/XV+mp9tb75vFpfra/WV+ubz6v11fpqfbW++bxaX62v1lfrm8+r9dX6an21vvm8Wl+tr9ZX65vPq/XV+mp9tb75vFpfra/WV+ubz6v11fpqfbW++bxaX62v1lfrm8+r9XX3Gs/DEWsaXvewECPnHvXsSUc8ZkpF5rPwPM6I4/AJT8bHHYxPgDHuWHnSk/EJB+OTYOT18Ph4Knlj+JuDJx2MT4Hnh8l7wt/APeXg+SF4nk7e0+Wpn+FvDp4J+taV28rAchynz3joYwra5W3zPBrVq95nwPNkxJqG1z0pxMi5pz170hGPmfo7b8UZcb8+68n4jIPxWTDGjb3nPBmfdTA+B8ZnY4zPezI+52B8HozPxRhf8GR83sH4AhifjzG+mLwx/OzxgoPxRfD8OHFPd/h7xxcdPD8Gz48S9+Q+eyTfz9xnj5eCvnXltjKwHMfASx76mIJ2eds8j8aBeucXmFfrq/XV+mp983m1vlpfra/WN59X66v11fpqffN5tb5aX62v1jefV+ur9dX6/v+qr/G8ELGm4XUvCDFy7keePemIx0ypyHwWnscZcRy+7Mn4koPxZTDGHSuveDK+7GB8BYy8Hh4fryZvDK85veJgfBU8ryfu6QmvOb3q4HkdPK8l7sldc0q+n7lrTm8EfevKbWVgOY7TNzz0MQXt8rZ5Ho2rqnd+gXl1PPj16nhQr44H9ebz6nhQr44H9ebz6nhQr44H9ebz6nhQr44H9ebz6nhQr44H9ebz6nhQr44H9ebz6nhQr44H9ebzShgPxvNKxJqG170ixMi51zx70hGPmVKR+Sw8jzPiOHzTk/ENB+ObYIw7Vt7yZHzTwfgWGN+MMb7tyfiWg/FtMPJ6eAy/k7wxvC/sbQfjO+B5L3lP+O8gvePgeQ887ybv6fLUz06zjfeDvnXltjKwHMfp+x76mIJ2eds8j0b1qvd98LwdsabhdW8LMXLuXc+edMRjpv7OW3FG3K8feDK+72D8AIxxY+/D5I3h+9EHDsYPwfNfyXvC96MPHTz/BZ6Pkvd0eepn+H70k6BvXbmtDCzHMfATD31MQbu8bZ5Ho3rV+xPwfBCxpuF1Hwgxcu4jz550xGOm/s5bcUbcrx97Mv7EwfgxGOPG3k+TN4bvRx87GH8Knv/x5Pmpg+d/wPPfyXu6PPUzfD/6WdC3rtxWBpbjGPiZhz6moF3eNs+jsZC8xvNxxJqG130sxMi5//bsSUc8ZurvuIoz4n79xJPxZw7GT8AYN/Z+7sn4iYPx52D8JMb4qSfjzx2Mn4KR18Pv5X6RvDE8z3/qYPwFeH7pyfMLB88vwfO/yXu6PPUzfN/5VdC3rtxWBpbjOP2Vhz6moF3eNs+jsZC8xvNpxJqG130qxMi5//XsSUc8ZurvuIoz4n79tSfjrxyMvwYjr4fny994Mv7awfgbMPJ6WMffejL+xsH4WzDyeljH33ky/tbB+Dsw8npYx997Mv7Owfh7MPJ6WMc/eDL+3sH4BzDyeljHP3oy/sHB+Ecw8npYxz95Mv7RwfgnMPJ6WMc/ezL+ycH4ZzDyeljHv3gy/tnB+Bcw8npYx796Mv7FwfhXMP4lxvg3T8a/Ohj/Bsa/xhg/82T8m4PxMzD+Lcb4uSfjZw7Gz8H4WYzx756MnzsY/w7Gz2OM//Bk/LuD8R9g5PUuAOM/PRn/4WD8Jxh5PazjF56M/3QwfgHGf8YYv/Rk/MLB+CUYv4gx/suT8UsH47/A+GWMkVfOJmz8l4ORF2ZgPd/GlG0PPZmIR9vWtrVtbVvb1ra1bW1b23Zr+8vk2u7GdouC3rZSnvoZRPr5VTfhsypPbcI8LcI8DcI8HcI8g4V5KoV5ioV5WoV5GoV5hgjzzBLmGSTMUyLMM1aYZ5gwT60wz2xhnrQwT6kwT7swz3BhnjphnjnCPFXCPBlhnjJhniZhnqHCPNXCPOXCPM3CPPXCPDXCPBXCPCkBnjQ4eErD8gBeVxRZ1xyPo+p6lxfbfBFsp8TmimO2XYzbts9LUn3XxToVe6oTtpVFt32sAgcv+7o9FcI8NcI89cI8zcI85cI81cI8Q4V5moR5yoR5MsI8VcI8c4R56oR5hgvztAvzlArzpIV5Zgvz1ArzDBPmGSvMUyLMM0iYZ5YwzxBhnkZhHr4fQIqnWJinUphnsDBPhzBPgzBPizBPmzBP0Ur08PeXvO2iiOfrbrvUPp+ZXNudZrtlnvpUbrdbZrfNfm6vBF7TYv8Q4O8fy6Ee/F1zKb4PpJZ/HfYjwXtzu6KW4kgfTLsVnuqX737kCiFtD0q+7fDfCqqAepspMhu2x9Mg8FR6qIWnfob/VlAaOsZ95rYysBzHWtrT/h4UOf/wPBoH6i0X4PW138x2qzyMe/O9eSXUtSpSX+xXZiUf8xlt+2ttuzr597VObMO8D/P4qoZ2B8Pns6TaNduq4fdzu212DAYPv2YD+FxQAfnsStoPNVAPbXvlt13roe00tMFTZDZsj6da8Azx9BnDQz/DY7wOOsZ9roX3bF6O96XXedrftZH3bJ6vAw9P+Du4Wk8enLLwvDbG0ybM0yLM0yDM0yHMM1iYp1KYp1iYp9zze5Crp1VYfRqFeYYI88wS5hkkzFMizDNWmCct7PwzTFh9aoV5ZgvzpIV5SoV52oV5hgvz1AnzzBHmqRLmyQjzlAnzNAnzDBXmqRbmKRfmaRbmqRfmqRHmqRDmSQnw5Pud4FfL4XX8nWwN5Iba50MgVxTTBn+XUwc5/nuPt2GO70l1fbeNdfL1PTS2lYV5bg9/J8jLvm5PhTBPjTBPvTBPszBPuTBPtTDPUGGeJmGeMmGejDBPlTDPHGGeOmGe4cI87cI8pcI8aWGe2cI8tcI8w4R5+G8bKZ6xwupTIswzSJhnljDPEGGeRmGeVmGecmHnn2Jh9akU5hkszNMhzNMgzNMizNMmzFO0Ej357uuuE9Z2kv8PD7PdBg99wu/neYrMhu3x1AD9rPfg8dTP8F71RugY95nbysByvDez0dM4akgtX1+ebwQPT3iveoMnD05ZeN4Q42kT5mkR5mkQ5ukQ5hkszFMpzFMszIPnQwmeVmH1aRTmGSLMM0uYZ5AwT4kwzzBhnlphntnCPGlhnlJhnnZhnuHCPHXCPHOEeaqEeTLCPGXCPE3CPEOFeaqFecqFeZqFeeqFeWqEeSqEeVICPPnuxebleO80f+eI91gPs8/rIVcU0wZ/V9EIOf57hrcRvReb81gnX9+zYltZmOf28F5sXvZ1eyqEeWqEeeqFeZqFecqFeaqFeYYK8zQJ85QJ82SEeaqEeeYI89QJ8wwX5mkX5ikV5kkL88wW5qkV5hkmzFMizDNImGeWMM8QYZ5GYZ5WYR6+H0CKp1hYfSqFeQYL83QI8zQI87QI87QJ8xRFPPnulfRlxCkLz+Pu3WwT5mkR5mkQ5ukQ5hkszFMpzFMszNMqzNMozDNEmGeWMM8gYZ4SYZ5hwjy1wjyzhXnSwjylwjztwjzDhXnqhHnmCPNUCfNkhHnKhHmahHmGCvNUC/OUC/M0C/PUC/PUCPNUCPOkBHji7k00x9k0uEeQ7zHk7/PwPkW8/5CfY7+Ge+oXtpWFeW4P7yXE38l/nZ4KYZ4aYZ56YZ5mYZ5yYZ5qYZ6hwjxNwjxlwjwZYZ4qYZ45wjx1wjzDhXnahXlKhXnSwjyzhXlqhXmGCfOUCPMMEuaZJcwzRJinUZinVZinWJinUphnsDBPhzBPgzBPizBPmzBP9DfE+e7d82XEKQvPh8d42oR5WoR5GoR5OoR5BgvzVArzFAvztArzNArzDBHmmSXMM0iYp0SYZ5gwT60wz2xhnrQwT6kwT7swz3BhnjphnjnCPFXCPBlhnjJhniZhnqHCPNXCPOXCPHz/khRPs7D61Avz1AjzVAjzpAR4BnIvYZN9Ad5LyOs3pfq+DvvV7Klf2FYW5rk9vJewKSXDUyHMUyPMUy/M0yzM05iS5SkXVp9qYZ6hwjxNwjxlwjwZYZ4qYZ45wjx1wjzDhXnahXlKhXnSwjyzhXlqhXmGCfOUCPMMEuaZJcwzRJinUZinVZinWJinUphnsDBPhzBPgzBPizBPmzBPUYynNXnPtDS0y1NkNmyPp1bwtHioj6d+hv/P7hHQMe4zt5WB5cOhjyM8jYHW1PL15fkRMW0n+P9+D+swcgV1GBljGbmS64BG9frzGs+siDUNr8P74r5OI+daYs6HCR4fXaYt/tsT9xl/37My9hleF8vC/Eht+2tte5Sn9188X5gpMhu2x9Mo8GQ9vf966Gf4vjM65hw5Co6x0THvv6M97e9RkXMOz6NxoN4R6l3lvabtMYm33d2ZjrRtpv6O/zGea+Gnn7njfyx0jPs8Bvb32Jj9PdbT/h4T2d88j0b1qle96lWvetWrXvWqV73qVa961ate9apXvepV74q9pu22xNvOfX+ObZspMhu2x1Ob51r46Wfu+/N26Bj3uQ32d3vM/m73tL/bIvub59GoXvWqV73qVa961ate9apXvepVr3rVq171qle96l2x17TdkXzb4e9PsG0zRWbD9njq8FwLT/0Mvz8fBx3jPnfA/h4Xs7/HedrfHZH9zfNoVK96x0Hb4xNvO3f9rMPh+B/vuRZ++pk7/idAx7jP42F/T4jZ3xM87e/xkf3N8xP8th3WYeIK6jAxxjJxJdcBjQP1jigwr9ZX66v11fpqfbW+Wl+tr9ZX66v11fpqfbW+Wl+tr9ZX66v1DUTX17Q9KfG2e8Lv5bFtM0Vmw/Z4muS5Fn76mfs+ejJ0jPs8Cfb35JjxOdnT/p4U2d88j8ZV1TtB66veQMeDenU8qHfFXh0P6tXxoN58Xh0P6tXxoN58Xh0P6tXxoN58Xh0P6tXxoN58Xh0P6tXxoN58Xh0P6tXxoN58XgnjwbQ9Jfm2u9ORts0UmQ3b42mK51p46md4/8hU6Bj3eQrs76kx43Oqp/09JbK/eR6NheQ1bXd6Gp9THMZnp+daeOpnOD67oGPc507Y310x+7vL0/7ujOxvnkdjIXnTkCsKenO8vBhy3TZXArkemyuF3DSbK4PcajZXDrnp0H/OzbC5SsitbnPtkFvD5kZCP9bkGkJuLft8FOTWts9HQ24d+3wM5Na1z8dCbj37vA1yM9kHufXt8w7IbWCfj4Pchvb5eMhtZJ9PhNzGkfdhk9sk8l5ocptGzocmt1nknGRym0fGoMltYZ8PCnpzs2A5P862uSrIzYHxzbktba4aclvZXA3ktra5wZDbxuaGQG6uzdVCblubq4PcdjY3FHLb21w95HawuQbI7WhzjZDbyeaGQW5nmxsOuV1srglyu9pcM+R2s7kWyO1uc62Q2yNmH/Ex2gk5PkbxmOZjtBtyfIz2QI6P0WmQ42N0NcjxMTodcnyMzoAcj53VIcdjZw3I8dhZE3I8dtaCHI+dtSHHY2cdyPHYWRdyPHbWgxyPnZmQ47GzPuR47GwAOR47G0KOx85GkOOxszHkeOxsAjkeO5tCjsfOZpDjsbM55HjsbAE5Hjt4zI6wudmQG2lzcyCXtbktITfK5raC3Gib2xpyY2xuG8iNtbm5kGuzuW0hx+f07SDXYXPbQ26cze0AufE2tyPkJtjcTpCbaHM7Q26Sze0Cuck2tyvkptjcbpCbanO743uoze0B718VsM1skNz7Orp4SkXms/CcDej5MjlPZwY82NbExPveHZ72eN8V2W3zuJoIbU9Irp9d/MS0zWPOnDdHgYXbK4HXVNmTTY01jU+8HjkTt11qt82m8WDi1wyu7X3tfbW99ZqUvK0bjyme+hunbMD9l5wn9281TXLwTABP8mM59zdT8v3s7MSxluRxbrYxLui7v7gPGVg+Hmo3zkPtcNzztnkejepVr3rVq171qle96lWvetWrXvWqV73qVa961aveFXvDe/8iVrzmNlmIkXNx14MS9HTitUq8BnMNXFfxfQ2szG67I9LnEnjNx3DN5wb7vAqW837Lty89XLfqd19+df0M+oPXYjzsy9AzMeJZ9dvu3sfPsdrdae7bMNfAeYyNi/SH9zFeO+YcXps0Y4DHIl93x2v6U73WZ2D7Bo+liZDj59y/IliHr1nPtPbOxO2580SX3RafJ7h9bq8EXvNY5Hp1lweTn752htRu6NOkmH7y8qfhfPiMfY73k/B4M8vfjFnOUyoyn4XnXDvT32nJ9zfct6vZbfG+nRbT9nSwJtR2F7adssHtcL4Enr/BN13B68zEdWa3OWZ6Yl6Hz8dH1snA8p6YfmcT7vc0sGRhntszY+Z5GF9vwmcBH5+JsN9YH/wMycsnQm5q5PXh/b32OZ5TfRyrKWiLt83znWDk3LivwdMW8eD9a/xas38PS/Xa/r/f7/RzeP+I+3zH63aAO8H7VJZzj4u4o587SuA1v4q873k4TperJd+nFf3bBWv5OziHtNobVPN9Zo++b/n8+wvfA7Mwz+3h5x5eVhT0PS/NDJY/nmcGydaaPaV2u9w+fh7g13wO+78I8h0Ra0/iNc0d3/wewu/j3H4PWPk1X0bGavKfLXKf0ZLva+69Cj8fTIzpJy8vtmPe7L9S+9yMdf5sw8eBWT40ZjlP/X1G49qZ/s5Ivr/hvl3dbov37YyYttcAa0Jtd2Hb/BmN2+F8CTyv45vg4XVm4jqz2xzf02Neh8+7IutkYPn0mH5nE+73DLBkYZ7bM2OmAsYXjx9j6vZgwn5jffA7K14+FnKTI68Pf0dln+O53sexip/xeds83wNGzuFnolaop4/7ZvEzEW87+v0XfjeH5wr8bo5/N5PgPbLhPb1lHvqMv+nhqb9zGxsqgt7f/STpGRT0/q5n6bLFS+btt2DugnnzU0AriTDxMRXTjSLI4fPimFwQLP/zJfxJIv98CX+SWBQpC/5sil/PP9nwUS6sB2+7JOKsAEuSbeNPv3jqb+iUg8fHUDZDp8puyw6dHZccsGwBjo/SiPPfGTtmWXE/r8u3LR4H/NoETw/dmZj28FSUDZIdczhl4Tn+rDf6Ojw28CfBRZF1zTgZBR+9SmPWKYtpj5/j8cnHQlnMulgnX8cmtpWFeW6vChy+T60DPVdIOE/NTK7t8M+OCk99qoR9lw2WP8cFto/8mjl2TPPPTDlvpuh7RhXUBX+yXhmpGR4/lfAYPfYS7TRjx8D2UxZSbDtdaotSbothUPzebjpnTljVthjmN7bmN7XmI5SpkfmNrPlNrPkNrPnNq/mNq/lNq/kNq/nNqvmNqvlNqvkNqvnNaTbIfRczGjwPg9F89jXfbZnfhJrPbubzsfm73XxnYD7Xmc9x5nOvuZ5ivqM0f8ubz8bms6f5TGr+pjKfR81nafOZ3/xtYz7zr0mxFsXaFOtQrEuxnq31+hQbUGxIsRHFxhSbUGxKsRnF5hRbUMyimE0xh2JLiq0otqbYhmIuxbYU21FsT7EDxY4UO1HsTLELxa4Uu1HsTrEHxZ4Ue1HMo9ibYh+K+RQLKPal2I9if4oDKL5B8U2KhRQHUiyiWExxEMW3KJZQLKVYRnEwxSEUh1IcRnE4xREUR1IcRXE0xTEUx1IcR3E8xQkUJ1KcRHEyxSkUp1KcRnE6xRkUZ1KcRXE2xTkU51KcR3E+xQUU36a4kOIiiospLqG4lOIyiu9QfJficoorKK6kuIriaoprKK6luI7ieoobKG6kuIniZopbKG6luI3idoo7KO6kuIvibop7KO6luI/ifooHKB6k+B7F9yl+QPFQkBtnj1A8SvEYxeMUT1A8SfEUxdMUP6R4huJZiuconqd4geJFih9R/JjiJYqXKV6heJXiNYrXKd6geJPiLYq3Kd6heJfiPYr3KT6g+JDio6D3BIAHf7P9MM2/CV9/yZJ5h2cPWDR/wWHZxQcvyy7eN7v34oMXzV+KK61vV1rbzm+b+zSVXbpw8bJsZ3YR/XfewoWLD10wf0oWly3NHnjw0mXZpcvmLVmW3XfJ4gOzXcv9WzJp+0fSKDs/b9myBQcetCy7bDGtuHDZAQctPDx76AHL9s8uPmTBkn2pAVz50dp/oyef/Cct/tKu3NJ35Xnz5+df7zO7Hn/1sXn/xi/+nY7NrhvgSsH/ATfSUsSGfQMA","debug_symbols":"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VEZWKiMrlZGVyshKZWSlMrJSGVmpjKxURlYqIyuVkZXKyEplZKUyslIZWamMrFRGViojK5WRlcrISmVkpTKyUhlZqYysVEZWKiMrlZGVyshKZWSlMrJSGVmpjKxURlYqIyuVkZXKyEplZKUyslIZWamMrFRGViojK5WRlcrISmVkpTKyUhlZqYysVEZWKiMrlZGVyshKZWSlMrJSGVmpjKxURlYqIyuVkZXKyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyI7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyK7KyNZDhWTPE0s+YfIJl09s+UTIJ1I+UfKJI5+Qe77kni+550vu+ZJ7vuSeL7nnS+75knu+5J4vuecm99zknpvcc5N7bnLPTe65yT03uecm99zknrvcc5d77nLPXe65yz13uecu99zlnrvcc5d7vuWeb7nnW+75lnu+5Z5vuedb7vmWe77lnm+55yH3POSeh9zzkHsecs9D7nnIPQ+55yH3POSep9zzlHuecs9T7nnKPU+55yn3POWep9zzlHtecs9L7nnJPS+55yX3vOSel9zzkntecs9L7vmRe37knh+550fu+ZF7fuSeH7nnR+75kXt+5J5fuedX7vmVe37lnl+551fu+ZV7fuWeX7nnModbModbModbModbMod7/vZVPhHyiZRPlHziyCfknsscbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskcbskczmQOZzKHM5nDmczhTOZwJnM4kzmcyRzOZA5nMoczmcOZzOFM5nAmcziTOZzJHM5kDmcyhzOZw5nM4UzmcCZzOJM5nMkczmQOZzKHM5nDmczhTOZwJnM4kzmcyRzOZA5nMoczmcOZzOFM5nAmcziTOZzJHM5kDmcyhzOZw5nM4UzmcCZzOJM5nMkczmQOZzKHM5nDmczhTOZwJnM4kzmcyRzOZA5nMoczmcOZzOFM5nAmcziTOZzJHM5kDmcyhzOZw5nM4UzmcCZzOJM5nMkczmQOZzKHM5nDmczhTOZwJnM4kzmcyRzOZA5nMoczmcOZzOFM5nAmcziTOZzJHM5kDmcyhzOZw5nM4UzmcCZzOJM5nMkczmQOZzKHM5nDmczhXOZwLnM4lzmcyxzOZQ7nModzmcO5zOFc5nAucziXOZzLHM5lDucyh3OZw7nM4VzmcC5zOJc5nMsczmUO5zKHc5nDuczhXOZwLnM4lzmcyxzOZQ7nModzmcO5zOFc5nAucziXOZzLHM5lDucyh3OZw7nM4VzmcC5zOJc5nMsczmUO5zKHc5nDuczhXOZwLnM4lzmcyxzOZQ7nModzmcO5zOFc5nAucziXOZzLHM5l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sXNnEzt3NrFzZxM7dzaxc2cTO3c2sXNnEzt3NrFzZxM7dzaxc2cTO3c2sXNnEzt3NrFzZxM7dzaxc2cTO3c2sXNnEzt3NrFzZxM7dzaxc2cTO3c2sXNnEzt3NrFzZxM7dzaxc2cTO3c2sXNnEzt3NrFzZxM7dzaxc2cTO3c2sXNnEzt3NrFzZxM7dzaxc2cTO3c2sXPnEzt3PrFz5xM7dz6xc+ePPfGRmPhITnykJj5yJj4yMfETO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7dz6xc+cTO3c+sXPnEzt3PrFz5xM7d/4zO3d7fZzb/vjxR17nsnmumudO89ztnfuZlbRfPrea56x5zpvndvNc876c5n05zftymvflNO/Lbd6X27wvt3lfbvO+3OZ9uc37cpv35Tbvy23el9u7L/vxaJ5bzXPWPOfNc7t5LprnsnmumudO81zzvqzmfVnN+7Ka92U178tq3pfVvC+reV9W876s5n1Zzftizftizftizftizftizftizftizftizftizftizfvizfvizfvizfvizfvizfvizfvizfvizfvizfvizfuym/dlN+/Lbt6X3bwvu3lfdvO+7OZ92c37spv3ZTfvSzTvSzTvSzTvSzTvSzTvSzTvSzTvSzTvSzTvSzTvSzbvSzbvSzbvSzbvSzbvSzbvSzbvSzbvSzbvSzbvSzXvSzXvSzXvSzXvSzXvS5Pv7ibf3U2+u5t8dzf57m7y3d3ku7vJd3eT7+4m391NvrubfHc3+e5u8t3d5Lu7yXd3k+/uJt/dTb67m3x3N/nubvLd3eS7u8l3d5PvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvRpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvZpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvVpPvnibfPU2+e5p89zT57mny3dPku6fJd0+T754m3z1NvnuafPd8zncfXw793Ymf/vH9z3+b+/Lg8/e/H49+fbe98d3+xnfvN7473vjufOO7643vPm98933fuz9n5L/Ru984l/bGubQ3zqW9cS7tjXNpb5xLe+Nc2hvn0t44l/7GufQ3zqW/cS79jXPpb5xLf+Nc+hvn0t84l/7GufQ3zuV+41zuXz+XrxMmn3D5xJZPfMt933Fff/fW84f18XCcj9fne19f7339eePr98+4k7/y9Ste93Odr3+R2XrEZ88+cdfr4SfB+vp01quW9QDVskC1GKgWB9Wyp2p5/lb54+FYn9YSoFoSVEuBajmgWi6nFhvL3ZPn9fB9fDrTtkC1jOXL3V9r2ffTWgJUS4JqKVAtB1TL5dTiD1AtC1SLgWpxUC2g3HVQ7joodx2Uuw7KXQfl7gbl7gbl7gbl7gbl7gbl7gbl7gbl7gbl7gbl7gblboByN0C5G6DcDVDuBih3A5S7AcrdAOVugHI3QLmboNxNUO4mKHcTlLsJyt0E5W6CcjdBuZug3E1Q7hYodwuUuwXK3QLlboFyt0C5W6DcLVDuFih3C5S7B5S7B5S7B5S7B5S7B5S7B5S7B5S7B5S7B5S7B5S7F5S7F5S7F5S7F5S7F5S7F5S7F5S7F5S7F5S7l5O7P/Pnv/5OtXBy92f+nNrfqRZO7v7Mn6f7O9XCyd2f+XN/f6daOLn7M38+8e9UCyh3Fyh3Fyh3Fyh3Fyh3Fyh3Fyh3Fyh3Fyh3Fyh3Fyh3DZS7BspdA+WugXIX5KsVyFcrkK9WIF+tQL5agXy1AvlqBfLVCuSrFchXK5CvViBfrUC+WoF8tQL5agXy1QrkqxXIVyuQr1YgX61AvlqBfLUC+WoF8tUK5KsVyFcrkK9WIF+tQL5agXy1AvlqBfLVCuSrFchXK5CvViBfrUC+WoF8tQL5agXy1QrkqxXIV6sxF8oej/3lYXtYflbLmAv1a2qZuru27uuv3Hj+0D6tZYNqCVAtCaqlQLWM/Z7hEe6vp58/jq/PR3xUc0nVjHk/ZudVjPl+/F2fPnnz8vz4o0bXtk+zeswTekft9h3X7t9x7fs7rj0Atb9qKVAtB1TL5dRyCdn+qoWQ1a9aCNn7qoWQpa9axrLRj33UcvzTWgJUS4JqKVAtB1TLxdRyxtyiX1PLAtVioFocVAsnd8+Dk7vnwcnd8+Dk7nlwcvc8QLm7QLm7QLm7QLm7QLm7QLm7QLm7QLm7QLm7QLm7QLlroNw1UO4aKHcNlLsGyl0D5a6BctdAuWug3DVQ7o45NPbI19+faY9P/xvrGXNofk0tG1RLgGpJUC0FquX8LrXkp7VcTi37AaplgWoxUC1ze1n2dc8mPv3n0ZhD82tqKVAtB1TL5dQy5or8mloWqBYD1TK49/mRdc+6Pq1lg2oJUC0JqqVAtczl7i/toJ64nFryAaplgWoxUC2cffuTG1QLZ9/+JGff/iRn3/4kKHcTlLsFyt0C5W6BchfkOR2Q53RAntMBeU4H5DmdAuVugXL3gHL3gHL3gHL3gHL3gHL3gHL3gHL3gHL3gHL3gHL3gnL3gnL3grLugrLuc7fFsr6c88f+OFbr49RpnbqNU/dzs+MXT63WKWud+vRX4wn3X7/4K+prq57/TfF17vbOfb5znfZis5nnkyo/347+xVPWOuWtU7t1Kj//VXzYx6+i2S/M1LKPoVr5+PEv+U8f9nq9eC//rJ6C1XNg9VxWPZ9v0v6O9SxYPQarx2H1bFg9AasHls8Gy2eD5bPB8tlh+eywfPa35vPrIz7xkT3xkZj4yG+RefX4+MiP/t3t0zuyHvfjT51ajx//i97+KKl4JR1eSRdX0n7wSlq8kgxU0vP//e8//cc//+m//8s//fl55vl///J//v0/f/i3/ws="},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":36}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"max_non_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_commitments","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"body_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243]},"bytecode":"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","debug_symbols":"q1bKyU9OLMnMzytWsqqu1VEqSyzKTEzKSYVySyoLIMxaAA=="},{"name":"get_game_address","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"count","type":{"kind":"field"},"visibility":"private"}],"param_witnesses":{"count":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[1]},"bytecode":"H4sIAAAAAAAA/81XzU7CQBDebctvsSA3E03mCciWeFIP9exNn6AGMCZAk7ZEfXkjhZnwuWmICVvDJDDT2enMN193t1utlNJqLz7YKOJLWJvTJHaYy2gL5xPbXfCTq3q3ZtqukgS/eREJtz9PLjims/21YVyzX+JG4NOAveUauzHTqr5vYbZ7ILBbgCdwjyduqE/TBc6/ldt52wF+fIunCxhvA3edBrjTUFdyyzVi/Cte7wzwNjkfuu7zTqNtjh7w2rX4xb76bDucj0Zx/UoCqNeHugO2tXK754bQqwYcA8AjMTesh2o/51QNP6H75xMf29ukHuLRZ4AnVPXvldDiDN81OJaAL2Ib44Zs+zW5I/AJL8Oae5GnCHpJ2DanyY4nrEVwLfUGgGN4Jng6/4gH5y3BdXQmtUdsJ8rtPn7ZUE9jztXm3IJf6gUQc89anrP4K5G1JPcPgJcxxIwtznA9y1iPuZS16vIsg2ckcpg3VIezosixfQ/PSQ28++O+OjyToszy9G3+PE9nGqAFFkzU9udFJR740PZrfIrLS5sB+GS7aIHPs2jBI7vE91TNZ1rC2pwmu7XgWw2jIDleTdw16wfWL3vOqVhmJRlab//T5TL7mM8mhGMFrTZFSUWZ5iUt8mxF8QTz3rG+Yv2Y5+kXva9n80/KNiVlC3rNNutZoX4A4Q+amdIOAAA=","debug_symbols":"1drBasJAEMbxd9lzKDuzs7M7eZXSQ9paEERFQ6FI3r2KMREMSlMDX24JzGZ+B/2LkINbbT6qerlZ7115cP5FXfl6cPtttT7d7+tqV7uS1MfCLdafp0vOTeG+lquFKyU0xc2wyWXWrB81GxglCto9mIStGydNzVtx9CQwTwbzGJiHPBqI0ECMBgpoIEEDRTQQWqYJrdOEFmpCKzWjlZrRSs1opeb/l5p8Ct2S4O+TMueL/ooz+Fw1bUcThf6p2sJlrvA4V7jOFZ7mCs9zhT/+ZQrxAZzYOrj66xW3wyFxOytXmkRnTfBQGoLSMJQmQGkEShOhNAqlSVCaDKWBarFAtVigWixQLRaoFgtUiwWqxQLVYoFqsUC1WKBaHCdt8XkFTb+Cp18Rpl/xjL4l360wvv/JIG/9/0LfD5NKC4poIEUDJTRQRgMZGEg9Gmjwa8+a2lPBy022NY44oyPOpBFn8ogz9rczx5vvares3leL0xsGx9v6Z3u+bH4B"},{"name":"get_latest_game_address","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[],"param_witnesses":{},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[0]},"bytecode":"H4sIAAAAAAAA/81YO4/aQBAeP8CAjbnQpZsq5cmglFHiSPkFSZdUjuCiSByWbKPcNenzp6PgY0d8Z8YECS/HSLCzz/nmsbO7JiJyaEce7cmh5/THlANo4+0vNXxyDr1NZv16EZ9UCra/nuFDGOeathtoE9xjOtRlAHO4K+xJMmvaioF3Abej6PUG+j1ljvCeMg718i3phbIY6iIvosP4GSv628SIxMD7Cp5L2Ox/eLRYCKFf87/01THzCfp7yhwZ21PGof59S/qjLIa6yMOY6V0JHlexmfSj39zG3CE9zyt/u8M+b4tbz5KdkBh4zD1a3J6St+q4/Q39Wtz2FXnCo1/EH31lLtqpB7qkhk/Ooyc7oSyGusjD+O5fAA8em0yH+/+lZQeGT7uTnQxofxfpWqch+I4Bv8jzYcwHU05MKe01YezXFIFdZFwIPMa42xgnecaCH+e4z4SO5QP0rY0z1JKeCZ4xHebpWb1GAPZp5qwx9GM+CCzYDs87WVvqiPFUvO4V4LUZDxZyyDym3X71AD+16DUyfIfxmBDt84YP8kYgNzK806Hceq0QdMVcGgEeGfPNlHXuxLsO2ifs3j9H7zoir+3u9VJ42u5eYcNmeHZgH969YsPjODm/PGXtGNrELhNlLtopBl1Swyfn0ZOdUBZDXeTh3WtyJXiCC+LBuGWox1ci+8bwKXWbx19Z0mlq1pK7oOAXeT6MeTSl+Fnaa5K9JPMjsMsUxkwbNsP9LH1yF5S92uVdxtY7HN9tQsfynu1304j2PimrvMh+LD8vs4UD0PwGTCwdRQ0X2pD3lDai9k8Mki605wA+eZvPiyEdmtTKt8AmOYqy2PbelK9N+bEoskf+uV4sHzjfVJzf8fd8s16UOOmrKd+Z8svOSVyu8ooTXm//s9Uq/7Vc3DL2lXy/KSsuq6yo+K7I73l2i+s+nAqG/gGRnoFYGxcAAA==","debug_symbols":"1ZvbiuJQEEX/5TzLUJdzK39lmIfMjAOC2E0rA4P47xPpJAqmla42svOWQK3UQirbnFwOYfPyq9mvX7a7sDwE+pbC8vsh7F6b7Wl/t2/e9mHJJdIirLa/T5vJjovwZ71ZhWXU449FC2UPVDxQ9UDmgZhcFLsocVHqoqKLcs0FfzAY2XqqEl1TxUVVF2UeSshFsYsSF6UuKrqo5KJcsyGu2RDXbIhrNtQ1G+qaDXXNhrpmQ12zoeO/fCLpqSRySS2ui1mGFpzPLSyPFGvpDxxZh9LCnY0h2USCsmEoG4GyUSibCGWToGwylE2BsoHK4giVxQkqixNUFieoLE5QWZwmzeL3Fmn6Fnn6FmX6Fo/ItzIsaNnk9mQwmQ7FdC7mHDshAxPKhCbEaEKCJqRoQhFNaPy0z5R6LEu9LWSxrzU7l5qNumseDsxR7EKodEIGJlQITYjRhARNSNGEIppQQhPKaEIFTQgtqQtaUle0pK5oSV3RkrqiJXVFS+r69aRmKueLQKXbSlVqby92+7jZcldaLhb3/YKy5rmKl7mK17mK20zFjeYqfv+fSdPxWfcBTaBsFMomQtkkKJsMZVOgbCqUjSHZMBGWDlQat/cJsXSg8pgJKpCZoBKZCSqS24srLB2oUG4fDkDpMFYqM1Yq86Sp3PXQJ/SIT+iRntDjEUn3yEd5zAXOqMIZGZqREJwRwxkJnNHo2S+5dJhSvI7w8ffv70HVA5kDGn/5/h7En4Panb/N27r5uVmdPppqd/f/Xt83j/8B"},{"name":"get_current_count","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[],"param_witnesses":{},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[0]},"bytecode":"H4sIAAAAAAAA/81UzU7DMAx20p+1dAiuHECWuKMU8QDlFXiDohbEZZW6TYKXRyzgqF+ziMuyaZ8U2XGc2PnimIhI0R8SmqBojgeRBdh4NxrRzSF4MnVuD0kpiMVuZKJX4KfFdg02BXm69e9YeRrzeEn7HBXAHceLVftvwKAnwIfvV8G6Bpv29lpe72E9C+zJA/Gcjm/ini4P7EWeMrhLI7o5DL88YSyGuYu3hDzyE+SDpcwwz84k9kL0Jl5sU9DUH2LfqYS3Y8jfxUvB507klUhnt8Dat1gCL86vAh1rXHt+Jc3/fsQ+Uxc01SlHPBf/qsN/febYf+VCuLVYb4axfe9f+rZTkFrqpYlSBa6hwYZ6ErARzVtVCjZXIqESwDbnl1RJ+5RG/QsJhREiA223Im9EPo9j+8Ufq67/5GG74eGNX4ftqlvTDyRa6fwWCAAA","debug_symbols":"zZfNisJAEITfpc9h6Z9xJpNXWfYwuxshEKKYIEjIu5ugxoMiGAzUrRuqpr7DTMH0VO/+UlftmpaKnvhrQ8V3T+0+NdPedunQUSEb1ozK5n8aVYeMtlVdUuFsyB7FovEmFs+zOPonYgu3g53YLA0y/GQjjEeCCUgwORJMRIIRhqIRKBqFojEoGgdFA9XDAlXEAtXEAlXFAtXFCtXFumoXXyJ0/QhbP8KtH/GJfgs8R0R9fTOEo81ivovFuyuQRwMKaEA5GlAEAzJGAxI0oKfPXn24uozdQ22bX+AJCzz5Ak983+P4Pc+4HNOhSr91Of3Rx7U77S/jcAY="}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    // TODO: change this to return a u64 as Noir now\n    // uses u64 for indexing\n    len: Field,\n    empty_value: T,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0, empty_value: initial_value }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> Field {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> Field {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + (i as Field)] = vec.get_unchecked(i as Field);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = self.empty_value;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}","path":"std/collections/bounded_vec.nr"},"31":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"contract Registry {\n    use dep::aztec::{\n        context::{PrivateContext, PublicContext, Context},\n        state_vars::{map::Map,  public_state::PublicState},\n        // types::type_serialization::{ // serialization methods for using booleans and field\n        //     bool_serialization::{BoolSerializationMethods, BOOL_SERIALIZED_LEN},\n        //     field_serialization::{FieldSerializationMethods, FIELD_SERIALIZED_LEN},\n        // },   \n        protocol_types::address::AztecAddress,\n    };\n\n    // storage\n    struct Storage {\n        games: Map<Field, PublicState<Field>>,\n        count: PublicState<Field>\n    }\n\n    impl Storage {\n      fn init(context: Context) -> Self {\n        Storage {\n            games: Map::new(\n                context,\n                1,\n                |context, slot| {\n                    PublicState::new(\n                        context,\n                        slot\n                    )\n                },\n            ),\n            count: PublicState::new(\n                context,\n                2\n            ),\n        }\n      }\n    }\n    \n    // docs:start:constructor\n    #[aztec(private)]\n    fn constructor() {}\n\n    #[aztec(public)]\n    fn add_game(game_address: Field) -> pub Field { \n        let new_game_count = storage.count.read() + 1;  \n        storage.games.at(new_game_count).write(game_address);\n        storage.count.write(new_game_count);\n        get_current_count()\n\n    }\n    unconstrained fn get_current_count() -> pub Field {\n        storage.count.read()\n    }\n\n    unconstrained fn get_game_address(count: Field) -> pub Field {\n        storage.games.at(count).read()\n    }\n\n    unconstrained fn get_latest_game_address() -> pub Field {\n        let current_count: Field = get_current_count();\n        get_game_address(current_count)\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: AztecAddress, nonce: Field, storage_slot: Field, note_type_id: Field, preimage: [Field; 0]) -> pub [Field; 4] {\n        [0, 0, 0, 0]\n    }\n}\n","path":"/Users/jack-sw/Codes/abstract/aztec-numer0n/aztec-contracts/contracts/registry/src/main.nr"},"58":{"source":"use crate::{\n    context::inputs::PublicContextInputs, messaging::process_l1_to_l2_message,\n    oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_COMMITMENTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_READ_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<SideEffect, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = StorageRead::empty();\n        let empty_storage_update = StorageUpdateRequest::empty();\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.call_context.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(0),\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_reads: BoundedVec::new(empty_storage_read),\n            public_call_stack_hashes: BoundedVec::new(0),\n            new_commitments: BoundedVec::new(SideEffect::empty()),\n            new_nullifiers: BoundedVec::new(SideEffectLinkedToNoteHash::empty()),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_commitments.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            self.this_portal_address(),\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(contract_address, function_selector, 0)\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"71":{"source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"85":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod avm;\n\nuse private_context::PrivateContext;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/aztec-nr/aztec/src/context.nr"},"96":{"source":"use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::std::option::Option;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_state_struct\nstruct PublicState<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_state_struct\n\nimpl<T> Storage<T> for PublicState<T> {}\n\nimpl<T> PublicState<T> {\n    // docs:start:public_state_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicState { context, storage_slot }\n    }\n    // docs:end:public_state_struct_new\n\n    // docs:start:public_state_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_state_struct_read\n\n    // docs:start:public_state_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public state writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_state_struct_write\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/aztec-nr/aztec/src/state_vars/public_state.nr"},"99":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"105":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/aztec-nr/aztec/src/hasher.nr"},"155":{"source":"global ARGS_LENGTH: Field = 16;\nglobal RETURN_VALUES_LENGTH: Field = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_COMMITMENTS_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as commitments and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX  MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_COMMITMENTS_PER_TX  MAX_NEW_COMMITMENTS_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX  MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_COMMITMENTS_PER_CALL: Field = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: Field = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: Field = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: Field = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: Field = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: Field = 16;\nglobal MAX_READ_REQUESTS_PER_CALL: Field = 32;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: Field = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_COMMITMENTS_PER_TX: Field = 64;\nglobal MAX_NEW_NULLIFIERS_PER_TX: Field = 64;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: Field = 8;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: Field = 8;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: Field = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: Field = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_TX: Field = 16;\nglobal MAX_NEW_CONTRACTS_PER_TX: Field = 1;\nglobal MAX_READ_REQUESTS_PER_TX: Field = 128;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: Field = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: Field = 1;\n\nglobal MAX_NEW_COMMITMENTS_PER_TX_META: Field = 8;\nglobal MAX_NEW_NULLIFIERS_PER_TX_META: Field = 8;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX_META: Field = 2;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: Field = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: Field = 3;\nglobal FUNCTION_TREE_HEIGHT: Field = 5;\nglobal CONTRACT_TREE_HEIGHT: Field = 16;\nglobal NOTE_HASH_TREE_HEIGHT: Field = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: Field = 40;\nglobal NULLIFIER_TREE_HEIGHT: Field = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: Field = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: Field = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\n\n// SUB-TREES RELATED CONSTANTS\nglobal CONTRACT_SUBTREE_HEIGHT: Field = 0;\nglobal CONTRACT_SUBTREE_SIBLING_PATH_LENGTH: Field = 16;\nglobal NOTE_HASH_SUBTREE_HEIGHT: Field = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: Field = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: Field = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: Field = 4;\nglobal ARCHIVE_HEIGHT: Field = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: Field = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: Field = 36;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: Field = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: Field = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\nglobal MAPPING_SLOT_PEDERSEN_SEPARATOR: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: Field = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 32;\n\n// CONTRACT CLASS CONSTANTS\n// This should be around 8192 (assuming 2**15 instructions packed at 8 bytes each),\n// but it's reduced to speed up build times, otherwise the ClassRegisterer takes over 5 mins to compile.\n// We are not using 1024 so we can squeeze in a few more args to methods that consume packed public bytecode,\n// such as the ClassRegisterer.register, and still land below the 32 * 32 max args limit for hashing.\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: Field = 1000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: Field = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: Field = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_LENGTH: Field = 8;\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: Field = 25;\nglobal MAX_NOTE_FIELDS_LENGTH: Field = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: Field = 23;\nglobal MAX_NOTES_PER_PAGE: Field = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: Field = 212;\nglobal CALL_CONTEXT_LENGTH: Field = 8;\nglobal GLOBAL_VARIABLES_LENGTH: Field = 6;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: Field = 8;\nglobal STATE_REFERENCE_LENGTH: Field = 10; // 2 for snap + 8 for partial\nglobal HEADER_LENGTH: Field = 20; // 2 for last_archive, 2 for body hash, 10 for state reference, 6 for global vars\nglobal FUNCTION_DATA_LENGTH: Field = 4;\nglobal CONTRACT_DEPLOYMENT_DATA_LENGTH: Field = 6;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 207;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: Field = 212;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: Field = 2;\nglobal CONTRACT_STORAGE_READ_LENGTH: Field = 2;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: Field = 187;\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: Field = 674;\nglobal COMMITMENTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 1024;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n  8                         | 0 < hash_index  32  |\n * | MID       | 8 < n  16                    | 32 < hash_index  40 |\n * | HIGH      | 16 < n  48                   | 40 < hash_index  48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size  8\nglobal GENERATOR_INDEX__COMMITMENT = 1;\nglobal GENERATOR_INDEX__COMMITMENT_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_COMMITMENT = 3;\nglobal GENERATOR_INDEX__SILOED_COMMITMENT = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size  16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size  44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/noir-protocol-circuits/src/crates/types/src/constants.nr"},"164":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\nglobal AZTEC_ADDRESS_SERIALIZED_LEN = 1;\nglobal ETH_ADDRESS_SERIALIZED_LEN = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/noir-protocol-circuits/src/crates/types/src/type_serialization.nr"},"167":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::{ContractClassFunctionLeafPreimage, FunctionLeafPreimage};\nuse crate::contract_class::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_COMMITMENT,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__COMMITMENT_NONCE, GENERATOR_INDEX__UNIQUE_COMMITMENT,\n    GENERATOR_INDEX__FUNCTION_ARGS\n};\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_commitment(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_COMMITMENT\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    content: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new(0);\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, portal_contract_address.to_field(), chain_id, content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_commitment_nonce(first_nullifier: Field, commitment_index: Field) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index\n    ],\n        GENERATOR_INDEX__COMMITMENT_NONCE\n    )\n}\n\npub fn compute_unique_siloed_commitment(nonce: Field, siloed_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_commitment\n    ],\n        GENERATOR_INDEX__UNIQUE_COMMITMENT\n    )\n}\n\npub fn compute_unique_siloed_commitments<N>(\n    first_nullifier: Field,\n    siloed_commitments: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_commitments = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_commitment = siloed_commitments[i];\n        if siloed_commitment.value != 0 {\n            let nonce = compute_commitment_nonce(first_nullifier, i);\n            unique_siloed_commitments[i] = SideEffect {\n                value: compute_unique_siloed_commitment(nonce, siloed_commitment.value),\n                counter: siloed_commitment.counter\n                };\n        }\n    }\n    unique_siloed_commitments\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n","path":"/Users/jack-sw/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.24.0/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr"}}}